<!doctype html>
<html>
    <head>
        <title>My Custom BIM Engine</title>
        <style>
            body {
                margin: 0;
                overflow: hidden;
                background-color: #f0f0f0;
            }

            /* 정보를 보여줄 팝업창 스타일 */
            #info-panel {
                position: absolute;
                top: 20px;
                right: 20px;
                width: 300px;
                padding: 15px;
                background: rgba(255, 255, 255, 0.9);
                border-radius: 8px;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
                font-family: "Segoe UI", sans-serif;
                display: none; /* 처음엔 숨김 */
            }
            h3 {
                margin-top: 0;
                color: #333;
            }
            p {
                margin: 5px 0;
                color: #666;
                font-size: 14px;
            }
            .label {
                font-weight: bold;
                color: #000;
            }
        </style>

        <script type="importmap">
            {
                "imports": {
                    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
                }
            }
        </script>
    </head>
    <body>
        <div id="info-panel">
            <h3 id="panel-title">정보</h3>
            <p><span class="label">ID:</span> <span id="data-id">-</span></p>
            <p><span class="label">Length:</span> <span id="data-length">-</span></p>
        </div>

        <script type="module">
            import * as THREE from "three";
            import { OrbitControls } from "three/addons/controls/OrbitControls.js";
            import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

            // 1. 씬 설정
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            const camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(10, 10, 10);

            const renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // 2. config 로드 후 같은 설정으로 JSON/glTF 로드 (파일명은 config.json 기준, 실패 시 아래 폴백)
            const configUrl = "models/config.json";
            let bimData = [];
            const defaultOutput = { gltf: "model.gltf", semanticTwinJson: "semantic_twin.json" }; // config 로드 실패 시에만 사용

            function onGltfLoaded(gltf) {
                const model = gltf.scene;
                model.traverse((child) => {
                    if (child.isMesh) {
                        child.material.side = THREE.DoubleSide;
                        child.material.roughness = 0.8;
                        child.material.metalness = 0.1;
                        const edges = new THREE.EdgesGeometry(child.geometry, 30);
                        const line = new THREE.LineSegments(
                            edges,
                            new THREE.LineBasicMaterial({ color: 0x333333 })
                        );
                        line.renderOrder = 1;
                        child.add(line);
                    }
                });
                scene.add(model);
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                model.position.sub(center);
                const maxDim = Math.max(size.x, size.y, size.z);
                const fov = camera.fov * (Math.PI / 180);
                let cameraZ = Math.abs(maxDim / 2 * Math.tan(fov * 2));
                cameraZ *= 2.0;
                camera.near = maxDim / 1000;
                camera.far = maxDim * 100;
                camera.position.set(cameraZ, cameraZ, cameraZ);
                camera.lookAt(0, 0, 0);
                camera.updateProjectionMatrix();
                controls.target.set(0, 0, 0);
                controls.update();
                console.log("glTF 로딩 완료! 크기:", maxDim);
            }

            const loader = new GLTFLoader();
            fetch(configUrl)
                .then((res) => res.ok ? res.json() : {})
                .then((cfg) => {
                    const out = (cfg && cfg.output) ? cfg.output : defaultOutput;
                    fetch("models/" + out.semanticTwinJson)
                        .then((r) => r.json())
                        .then((json) => { bimData = json; })
                        .catch((err) => console.error(err));
                    return out;
                })
                .then((out) => {
                    loader.load(
                        'models/' + out.gltf,
                        onGltfLoaded,
                        (xhr) => console.log((xhr.loaded / xhr.total * 100) + '% loaded'),
                        (error) => console.error('에러 발생:', error)
                    );
                })
                .catch(() => {
                    loader.load('models/model.gltf', onGltfLoaded, () => {}, (err) => console.error(err));
                });

            // --- 클릭 이벤트 ---
            const raycaster = new THREE.Raycaster();
            const pointer = new THREE.Vector2();

            // 이전에 선택했던 벽을 기억할 변수 (원래 색으로 되돌리기 위해)
            let lastSelectedMesh = null;
            let originalColorHex = null;

            window.addEventListener("click", onMouseClick);

            function onMouseClick(event) {
                pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
                pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(pointer, camera);
                const intersects = raycaster.intersectObjects(scene.children, true);
                const hit = intersects.find(i => i.object.isMesh);

                if (hit) {
                    // 클릭된 메쉬 가져오기
                    const hitMesh = intersects[0].object;

                    // 1. 이전에 빨갛게 만든 벽이 있으면 원래대로 돌려놓기
                    if (lastSelectedMesh && lastSelectedMesh !== hitMesh) {
                        if (originalColorHex !== null) {
                            lastSelectedMesh.material.color.setHex(originalColorHex);
                        }
                    }

                    // 2. 지금 클릭한 벽이 "공용 페인트통"을 쓰고 있다면, "새 페인트통(Clone)"으로 교체
                    // (재질이 여러 개 공유되는 걸 막기 위함)
                    if (!hitMesh.userData.isMaterialCloned) {
                        hitMesh.material = hitMesh.material.clone();
                        hitMesh.userData.isMaterialCloned = true;
                    }

                    // 3. 현재 색상 기억해두기 (나중에 되돌리려고)
                    if (lastSelectedMesh !== hitMesh) {
                        originalColorHex = hitMesh.material.color.getHex();
                    }

                    // 4. 파란색으로 변경
                    hitMesh.material.color.set(0x00aaff);
                    lastSelectedMesh = hitMesh;

                    // 5. 정보 띄우기
                    showData(hitMesh);
                } else {
                    // 허공 클릭 시 패널 숨기기 & 색상 복구
                    if (lastSelectedMesh && originalColorHex !== null) {
                        lastSelectedMesh.material.color.setHex(originalColorHex);
                        lastSelectedMesh = null;
                    }
                    document.getElementById("info-panel").style.display = "none";
                }
            }

            function showData(mesh) {
                const panel = document.getElementById("info-panel");
                panel.style.display = "block";

                // OBJ 파일에서 설정한 'o {ID}' 이름 가져오기
                // Three.js OBJLoader는 그룹핑 방식에 따라 mesh.name 혹은 mesh.parent.name에 ID를 넣습니다.
                let elementId = mesh.name;
                if (!elementId || elementId.includes("_") || elementId.length < 3) {
                    if(mesh.parent && mesh.parent.name) elementId = mesh.parent.name;
                }

                console.log("선택된 ID:", elementId);

                // JSON에서 해당 ID 검색
                const data = bimData.find((d) => d.id === elementId);

                if (data) {
                    document.getElementById("data-id").innerText = data.id;
                    document.getElementById("data-length").innerText = data.length; // 단위 추가 등은 자유롭게
                } else {
                    // 매핑 실패 시
                    document.getElementById("data-id").innerText = elementId || "ID 없음";
                    document.getElementById("data-length").innerText = "-";
                }
            }

            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            animate();

            window.addEventListener("resize", () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        </script>
    </body>
</html>
